using System;
using System.Collections.Generic;
using AquaCoaster.Model.Enums;
using AquaCoaster.Utilities;


namespace AquaCoaster.Model.Entities
{
    public abstract class Infrastructure : IPlaceable
    {

        #region Fields

        private const InfrastructureStatus DEFAULT_STATUS = InfrastructureStatus.OPERATING;

        #endregion

        #region Properties

        public String Name { get; protected set; }

        public Int32 Price { get; protected set; }

        public Point Size { get; protected set; }

        /// <summary>
        /// Points of the <see cref="Infrastructure"/> where a <see cref="Person"/> can be placed.
        /// In case of null the person will be placed inside the inner area of the <see cref="Infrastructure"/>,
        /// where inner means every point except the outermost points.
        /// In case of size(X|Y) <= 2 there are no boundaries on that axis.
        /// </summary>
        public List<Point> UseableArea { get; protected set; }

        private InfrastructureStatus _status = DEFAULT_STATUS;

        public InfrastructureStatus Status
        {
            get => _status;
            set
            {
                if (_status != value)
                {
                    _status = value;
                    OnAttributesChanged();
                }
            }
        }

        public List<Type> StackableInfrastructure { get; protected set; } = new List<Type>();

        #endregion

        #region Events

        public event EventHandler<Int32> ExpenseGenerated;

        public event EventHandler<List<Person>> InteractionEnded;

        public event EventHandler<List<Person>> WaitingEnded;

        public event EventHandler AttributesChanged;

        #endregion

        #region Constructor

        protected Infrastructure(Dictionary<String, Object> config)
        {
            if (config.ContainsKey("Status"))
            {
                this.Status = (InfrastructureStatus)config["Status"];
            }
            else
            {
                this.Status = default(InfrastructureStatus);
            }

            if (config.ContainsKey("UseableArea"))
            {
                this.UseableArea = (List<Point>)config["UseableArea"];
            }
            else
            {
                this.UseableArea = null;
            }

            if (config.ContainsKey("StackableInfrastructure"))
            {
                this.StackableInfrastructure = (List<Type>)config["StackableInfrastructure"];
            }

            /* Non-default config params */
            this.Name = (String)config["Name"];
            this.Price = (Int32)config["Price"];
            this.Size = (Point)config["Size"];
        }

        #endregion

        #region Methods

        /// <summary>Method to synchronize the infrastructure to the timer.</summary>
        /// <param name="passedMillis"></param>
        public virtual void Tick(Int64 passedMillis) { }

        #endregion

        #region Private/Protected event methods

        /// <summary>
        /// Let's the attached event handlers know that some expense was generated by the infrastrucutre.
        /// </summary>
        /// <param name="amount">The amount generated. Positive value means income, negative means expense.</param>
        protected void OnExpenseGenerated(Int32 amount)
        {
            ExpenseGenerated?.Invoke(this, amount);
        }

        /// <summary>
        /// Let's the attached event handlers know about the people who finished interacting with the infrastrucutre.
        /// </summary>
        /// <param name="people"></param>
        protected void OnInteractionEnded(List<Person> people)
        {
            InteractionEnded?.Invoke(this, people);
        }

        /// <summary>
        /// Let's the attached event handlers know about the people who got a slot in the infrastrucutre,
        /// for e.g. after being in the WaitingQueue
        /// </summary>
        /// <param name="people"></param>
        protected void OnWaitingEnded(List<Person> people)
        {
            WaitingEnded?.Invoke(this, people);
        }

        /// <summary>
        /// Let's the attached event handlers know about the changes in the state of an infrastructure element.
        /// <para>Should be called on changes made to the infrastructure element.</para> 
        /// </summary>
        protected void OnAttributesChanged()
        {
            AttributesChanged?.Invoke(this, EventArgs.Empty);
        }

        #endregion

    }
}
